<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>pixijs</title>
  <script src="./js/pixi.min.js"></script>
  <style type="text/css">
    body,
    html {
      margin: 0;
      padding: 0;
    }

    body {
      box-sizing: border-box;
      height: 100vh;
      background-image: -webkit-gradient(linear, left top, left bottom, from(#fed59f), to(#ffe96f));
    }

    #canvas {
      width: 100%;
      box-sizing: border-box;
    }
  </style>
</head>

<body>
  <script>
    // 游戏基础配置
    const unit_size = { width: 50, height: 50 };
    const table = { x: 10, y: 10 };
    
    // 创建画布
    const app = new PIXI.Application(table.x * unit_size.width, table.y * unit_size.height, {
      backgroundColor: 0xf1c16c,
      antialias: true
    });
    app.view.id = 'canvas';

    app.stage.interactive = true;

    document.body.appendChild(app.view);

    // 创建舞台
    let container = new PIXI.Container();
    container.x = 0;
    container.y = 0;

    app.stage.addChild(container);


    let unitTexture = PIXI.Texture.fromImage('./assets/images/unit.svg');
    let unitBlockTexture = PIXI.Texture.fromImage('./assets/images/unit-block.svg');
    let unitBlockActiveTexture = PIXI.Texture.fromImage('./assets/images/unit-block-active.svg');

    // 方格二维数组
    let unit_data = [
      [
        { y: 0, x: 1 },
        { y: 0, x: 5 },
        { y: 0, x: 6 },
        { y: 0, x: 7 },
        { y: 0, x: 8 }
      ],
      [
        { y: 1, x: 1 },
        { y: 1, x: 3 },
        { y: 1, x: 8 }
      ],
      [
        { y: 2, x: 1 },
        { y: 2, x: 2 },
        { y: 2, x: 3 },
        { y: 2, x: 4 },
        { y: 2, x: 6 },
        { y: 2, x: 7 },
        { y: 2, x: 8 }
      ],
      [
        { y: 3, x: 3 },
        { y: 3, x: 7 }
      ],
      [
        { y: 4, x: 0 },
        { y: 4, x: 1 },
        { y: 4, x: 2 },
        { y: 4, x: 3 },
        { y: 4, x: 6 },
        { y: 4, x: 7 },
        { y: 4, x: 8 },
        { y: 4, x: 9 }
      ],
      [
        { y: 5, x: 1 },
        { y: 5, x: 7 }
      ],
      [
        { y: 6, x: 1 },
        { y: 6, x: 4 },
        { y: 6, x: 5 },
        { y: 6, x: 6 },
        { y: 6, x: 7 }
      ],
      [
        { y: 7, x: 1 },
        { y: 7, x: 4 }
      ],
      [
        { y: 8, x: 1 },
        { y: 8, x: 2 },
        { y: 8, x: 3 },
        { y: 8, x: 4 }
      ],
      [
        { y: 9, x: 0 },
        { y: 9, x: 1 }
      ]
    ];

    // tips
    let tips = {
      '21222324': '赫拉利将告诉你人类是如何从动物变成上帝',
      '40414243': '对两次世界大战的哲学思考，直面存在的危机',
      '81828384': '看萧红写的这书名还以为是一条河的历史',
      '9091': '鲁迅先生的短篇小说集，里面有《狂人日记》',
      '64656667': '天下合久必分，分久必合',
      '46474849': '与达尔文《物种起源论》及哥白尼《天体运行论》并称为人类三大思想革命的经典之作',
      '262728': '三位艺术天才的非凡人生，罗曼罗兰著',
      '5678': '证明你上过中学的又一个有力佐证，冰心奶奶如是说',
      '11121': '我们都是故事外的人——阿尔贝·加缪',
      '13233343': '一种追求简单生活的价值观',
      '415161718191': '余华手下一本关于记忆的长篇小说',
      '647484': '走遍万水千山，泪尽撒哈拉',
      '2737475767': '达康书记别低头，皇冠会掉',
      '81828': '中国四大名著之一'
    }

    // 创建 12 * 8 的方格
    let unit = [];
    let unit_block = [];

    creatTable(table, unit_data);

    function creatTable(table, block) {
      let row = table.x;
      let col = table.y;
      let index = 0;
      let width = unit_size.width * table.x * unit_size.width;
      let height = unit_size.width * table.y * unit_size.height;

      let i = 0;
      while (i < row) {
        unit.push([]);
        let k = 0;
        while(k < col) {
          let sprite = new PIXI.Sprite(unitTexture);
          let x = (k * unit_size.width) % width;
          let y = (i * unit_size.height) % height;
          sprite.interactive = true;
          sprite.isDown = false;
          sprite.isEmpty = true;
          sprite.anchor.set(0, 0);
          sprite.width = unit_size.width;
          sprite.height = unit_size.height;
          sprite.index = index++; // 唯一id
          sprite.x = x;
          sprite.y = y;
          sprite.X = x / unit_size.width; // x坐标
          sprite.Y = y / unit_size.height; // y 坐标
          unit[i].push(sprite);
          container.addChild(sprite);
          k++;
        }
        i++;
      }

      // 添加事件
      for (let row = 0, uLen = unit.length; row < uLen; row++) {
        add: for(let col = 0, len = unit[row].length; col < len; col++) {
          // console.log(unit[row][col].x / unit_size.width, unit[row][col].y / unit_size.height);
          for (let k = 0, fLen = block[row].length; k < fLen; k++) {
            if (block[row][k].x === col && block[row][k].y === row) {
              unit[row][col].isEmpty = false;
              unit[row][col].texture = unitBlockTexture;
              unit[row][col].buttonMode = true;
              unit[row][col].on('pointerdown', onClick);
              unit_block.push(unit[row][col]);
              continue add;
            }
          }
        }
      }
    }

    function onClick() {
      const X = this.X, Y = this.Y
      console.log(X, Y);
      let cols = [], rows = unit[Y];
      // 重置默认
      reset(unit_block);
      if (this.selectRow) console.log(this.selectRow);

      this.isDown = !this.isDown;
      unit.forEach((row) => {
        if (row[X].X === X) cols.push(row[X]);
      });

      console.log(cols.map(item => {
        return {x: item.X, y: item.Y};
      }));

      if (this.selectRow !== undefined) {
        if (this.isDown && this.selectRow) {
          renderCol(X, Y, cols, rows);
        } else {
          renderRow(X, Y, rows, cols);
        }
      } else {
        if (this.isDown) {
          renderRow(X, Y, rows, cols);
        } else {
          renderCol(X, Y, cols, rows);
        }
      }
    }

    // 渲染行
    function renderRow(x, y, row, col) {
      let unit = aroundUnit(row, x, y, true);
      let len = unit.length;
      // 如果临近元素为为空 (1 代表自身) 渲染列
      if (len <= 1) {
        renderCol(x, y, col, row);
        return;
      }

      unit.forEach((item) => {
        item.texture = unitBlockActiveTexture;
        item.selectRow = true;
      });

      // var unit = stor(unit);
      // selectUnit.isRow = true;
      // selectUnit.unit = unit;
    }

    // 渲染列
    function renderCol(x, y, col, row) {
      var unit = aroundUnit(col, x, y, false);
      var len = unit.length;
      // 如果临近元素为空 (1 代表自身) 渲染行
      if (len <= 1) {
        renderRow(x, y, row, col, true);
        return;
      }
      unit.forEach((item) => {
        item.texture = unitBlockActiveTexture;
        item.selectRow = false;
      });

      // var unit = stor(unit);
      // selectUnit.isRow = false;
      // selectUnit.unit = unit;
    }

    // 获取相邻元素  arry 一维数组 行 或者 列
    function aroundUnit(arry, x, y, selectRow) {
      let n = selectRow ? x : y;
      let len = arry.length;
      let unit = [];
      for (let i = 0; i < len; i++) {
        if (arry[n + i] && arry[n + i].isEmpty) break;
        if (arry[n + i]) {
          unit.push(arry[n + i]);
        };
      }

      for (let i = 1; i < len; i++) {
        if (arry[n - i] && arry[n - i].isEmpty) break;
        if (arry[n - i]) unit.push(arry[n - i]);
      }
      return unit;
    }

    // 重置视图
    function reset(unit) {
      unit.forEach((item) => {
        item.isDown = false;
        item.texture = unitBlockTexture;
      });
    }

    // 绘制边框
    drawBorder(table, unit_data, container);

    function drawBorder(table, block, ctx) {
      let row = table.x, col = table.y;
      let containerWidth = table.x * unit_size.width, containerHeight = table.y * unit_size.height;
      let startY = unit_size.height, startX = unit_size.width;
      drawLine({ width: 1, color: 0xb38743, alpha: 1 }, ctx, containerWidth, containerHeight, startX, startY, row, col);
    }

    // 绘制线条
    function drawLine(lineStyle, ctx, width, height, X, Y, col, row) {
      let i = 1, n = 1;
      const graphics = new PIXI.Graphics();
      // 绘制行
      while (i < row) {
        graphics.beginFill();
        graphics.lineStyle(lineStyle.width, lineStyle.color, lineStyle.alpha);
        graphics.moveTo(0, Y * i);
        graphics.lineTo(width, Y * i);
        graphics.endFill();
        ctx.addChild(graphics);
        i++
      }
      // 绘制列
      while (n < col) {
        graphics.beginFill();
        graphics.lineStyle(lineStyle.width, lineStyle.color, lineStyle.alpha);
        graphics.moveTo(X * n, 0);
        graphics.lineTo(X * n, height);
        graphics.endFill();
        ctx.addChild(graphics);
        n++
      }
    }
  </script>
</body>

</html>